(ns noisesmith.egregore
  (:require [clojure.string :as string]))

(defn number-present?
  [m ks]
  (and (map? m)
       (every? (comp number? m)
               ks)))

;; obsessed with the inviolability of my identity
;; my choices
;; my selfhood

;; to the degree that things others consider
;; normal are perceived to be threats

;; to the consequence that my own self is
;; perceived easily to be a threat

;; generate a series of cut points as in,out pairs
;; plus the data (any needed) generated by sculpting-f

(defn event-slicer
  [sculpting-f {:keys [timestamp min-duration max-duration total-time] :as state}]
  (assert (number-present? state [:timestamp :min-duration :max-duration :total-time]))
  (let [slice-data (sculpting-f state)
        {:keys [in-lag duration out-lag slice]} slice-data]
    (assert (number-present? slice-data [:in-lag :duration :out-lag]))
    (-> state
        (merge slice-data)
        (assoc :event {:in (+ timestamp in-lag)
                       :duration duration
                       :data slice})
        (update :timestamp + in-lag duration out-lag))))

(defn check-timeout
  [{:keys [timestamp total-time] :as step}]
  (<= timestamp total-time))

(defn eviscerate
  [sculpting-f init]
  (assert (number-present? init [:min-duration :max-duration :total-time]))
  (let [slices (iterate (partial event-slicer sculpting-f)
                        (merge  {:timestamp 0
                                 :total-time 0}
                               init))]
    (take-while check-timeout
                slices)))

(defn simple-melody
  []
  (eviscerate
   (fn [state]
     (assoc state
            :in-lag 1
            :duration 1
            :out-lag 1
            :slice ::TBD))
   {:timestamp 0
    :min-duration 0
    :max-duration 1
    :total-time 10}))

#_
(clojure.pprint/pprint
 (doall (simple-melody)))

(def table-headers
  ["f 1 0 0 1 \"src.ardour/Untitled-2021-04-27-09-30-00/export/session.wav\" 0 4 1"
   "f 2 0 0 1 \"src.ardour/Untitled-2021-04-27-09-30-00/export/session.wav\" 0 4 2"])

(defn granulatable
  []
  (eviscerate
   (fn [state]
     (assoc state
            :in-lag 0
            :duration 10
            :out-lag 0
            :slice {:t 420
                    :vl 0
                    :vr 0
                    :fade-in 0.6
                    :fade-out 0.6
                    :src 1}))
   {:timestamp 0
    :min-duration 10
    :max-duration 10
    :total-time 10}))

(defn evdata->scodata
  [{:keys [in duration data :as ev]}]
  (let [{:keys [t vl vr fade-in fade-out src]} data]
    ["i1" in duration vl vr t fade-in fade-out src]))

(defn event->sco
  [row-data]
  (some->> row-data
           (:event)
           (evdata->scodata)
           (string/join " ")
           (list)))

(defn gran-score
  []
  (into table-headers
        (cons ""
              (mapcat event->sco
                      (granulatable)))))

(def dummy-score
  (into table-headers
        [""
         "i 1 0 10 0 0 420 .6 .6 1"]))

(def simple-instrument
  ["sr = 48000"
   "ksmps  = 1"
   "nchnls = 2"
   "0dbfs  = 1"
   ""
   "  instr 1"
   "idur      init p3"
   "idbl      init p4"
   "idbr      init p5"
   "ipos      init p6"
   "ifade_in  init p7"
   "ifade_out init p8"
   "itb       init p9"
   ""
   "apos      init (ipos * sr)"
   "asig      tab apos, itb, 0"
   "ipeak     = idur - (ifade_in + ifade_out)"
   "aenv      linseg -65, ifade_in, 0, ipeak, 0, ifade_out, -65"
   "          outs asig*ampdb(aenv+idbl), asig*ampdb(aenv+idbr)"
   ""
   "apos      = apos + 1"
   "  endin"])

(defn -main
  [& args]
  (run! println (gran-score)))
