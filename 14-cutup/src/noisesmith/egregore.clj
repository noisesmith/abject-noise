(ns noisesmith.egregore
  (:require [clojure.string :as string]
            [noisesmith.generative :as gen]))

(defn number-present?
  [m ks]
  (and (map? m)
       (every? (comp number? m)
               ks)))

;; obsessed with the inviolability of my identity
;; my choices
;; my selfhood

;; to the degree that things others consider
;; normal are perceived to be threats

;; to the consequence that my own self is
;; perceived easily to be a threat

;; generate a series of cut points as in,out pairs
;; plus the data (any needed) generated by sculpting-f

(defn event-slicer
  [sculpting-f {:keys [timestamp min-duration max-duration total-time] :as state}]
  (assert (number-present? state [:timestamp :min-duration :max-duration :total-time]))
  (let [slice-data (sculpting-f state)
        {:keys [in-lag duration out-lag slice]} slice-data]
    (assert (number-present? slice-data [:in-lag :duration :out-lag]))
    (-> state
        (merge slice-data)
        (assoc :event {:in (+ timestamp in-lag)
                       :duration duration
                       :data slice})
        (update :timestamp + in-lag duration out-lag))))

(defn check-timeout
  [{:keys [timestamp total-time] :as step}]
  (<= timestamp total-time))

(defn eviscerate
  [sculpting-f init]
  (assert (number-present? init [:min-duration :max-duration :total-time]))
  (let [slices (iterate (partial event-slicer sculpting-f)
                        (merge  {:timestamp 0
                                 :total-time 0}
                               init))]
    (take-while check-timeout
                slices)))

(defn simple-melody
  []
  (eviscerate
   (fn [state]
     (assoc state
            :in-lag 1
            :duration 1
            :out-lag 1
            :slice ::TBD))
   {:timestamp 0
    :min-duration 0
    :max-duration 1
    :total-time 10}))

#_
(clojure.pprint/pprint
 (doall (simple-melody)))

(def table-headers
  ["f 1 0 0 1 \"src.ardour/Untitled-2021-04-27-09-30-00/export/session.wav\" 0 4 1"
   "f 2 0 0 1 \"src.ardour/Untitled-2021-04-27-09-30-00/export/session.wav\" 0 4 2"])

(defn simplified-granulatable
  []
  (eviscerate
   (fn [state]
     (assoc state
            :in-lag 0
            :duration 10
            :out-lag 0
            :slice {:t 420
                    :vl 0
                    :vr 0
                    :fade-in 0.6
                    :fade-out 0.6
                    :src 1}))
   {:timestamp 0
    :min-duration 10
    :max-duration 10
    :total-time 10}))

(defn evdata->scodata
  [{:keys [in duration data :as ev]}]
  (let [{:keys [t vl vr fade-in fade-out src]} data]
    ["i1" in duration vl vr t fade-in fade-out src]))

(defn event->sco
  [row-data]
  (some->> row-data
           (:event)
           (evdata->scodata)
           (string/join " ")
           (list)))

(defn simplified-gran-score
  []
  (into table-headers
        (cons ""
              (mapcat event->sco
                      (simplified-granulatable)))))

(def dummy-score
  (into table-headers
        [""
         "i 1 0 10 0 0 420 .6 .6 1"]))

(def simple-instrument
  ["sr = 48000"
   "ksmps  = 1"
   "nchnls = 2"
   "0dbfs  = 1"
   ""
   "  instr 1"
   "idur      init p3"
   "idbl      init p4"
   "idbr      init p5"
   "ipos      init p6"
   "ifade_in  init p7"
   "ifade_out init p8"
   "itb       init p9"
   ""
   "apos      init (ipos * sr)"
   "asig      tab apos, itb, 0"
   "ipeak     = idur - (ifade_in + ifade_out)"
   "aenv      linseg -65, ifade_in, 0, ipeak, 0, ifade_out, -65"
   "          outs asig*ampdb(aenv+idbl), asig*ampdb(aenv+idbr)"
   ""
   "apos      = apos + 1"
   "  endin"])

(defn sequence-a
  [{:keys [voices start-time end-time max-slice-len sample-location]}]
  (let [voices (or (some-> voices (long))
                   1)
        start-time (or (some-> start-time (double))
                       0.0)
        end-time (some-> end-time (double))
        sample-location (or (some-> sample-location (double))
                            0.0)
        max-slice-len (or (some-> max-slice-len (double))
                          3.0)
        slicer (fn slicer []
                 (let [durations #(gen/curve {:mn 0.01 :mx max-slice-len :slope Math/PI})
                       sample-locations (fn [duration]
                                          (gen/curve {:mn sample-location
                                                      :mx (+ sample-location 20 duration)
                                                      :slope 2}))
                       fades #(gen/curve {:mn 0 :mx (/ % 2)})
                       sources #(inc (rand-int 2))
                       amps #(gen/curve {:mn % :mx 0 :slope 1.3})
                       lags #(gen/curve {:mn 0 :mx (/ % 4)})]
                   (eviscerate
                    (fn [state]
                      (let [duration (durations)
                            short-boost (gen/translate [0.1 3] [-25 -65] duration)]
                        (assoc state
                               :in-lag (lags duration)
                               :duration duration
                               :out-lag (lags duration)
                               :slice {:t (sample-locations duration)
                                       :vl (amps short-boost)
                                       :vr (amps short-boost)
                                       :fade-in (fades duration)
                                       :fade-out (fades duration)
                                       :src (sources)})))
                    {:timestamp start-time
                     :min-duration 10
                     :max-duration 10
                     :total-time end-time})))]
    (apply concat
           (repeatedly voices
                       slicer))))

(defn granulatable
  []
  (concat (sequence-a {:voices 50
                       :start-time 0
                       :end-time 100
                       :sample-location 400
                       :max-slice-len 3})
          (sequence-a {:voices 90
                       :start-time 80
                       :end-time 180
                       :sample-location 500
                       :max-slice-len 0.3})
          (sequence-a {:voices 10
                       :start-time 175
                       :end-time 300
                       :sample-location 800
                       :max-slice-len 0.1})))

(defn gran-score
  []
  (into table-headers
        (cons ""
              (mapcat event->sco
                      (granulatable)))))

(defn -main
  [& args]
  (run! println (gran-score)))
