[_] conway's game of life in ARM assembler
	: build it to run on qemu userspace (the qemu-arm program)
	[X] set up basic tdd with log output
		: xxd helps, made a hex output generator
	[_] move debugging facilities into a reusable resource
	[_] data representation
		[X] one bit per cell?
			: one bit per cell, so 64 cells per memory location
			: at first: just 64 memory locations, to make a 64x64 grid
	[_] functionality
		[_] break the skeleton into smaller functions
			[_] use the stack on each call (for return address for now)
		[_] print the board
		: use system calls to print to stdout
		: should be a simple loop
			[_] print the correct number of lines
				: currently prints 37 lines(!)
			[_] print the correct contents per line
				: currently there are multiple unexpected results
		[_] update one cell
		: OR of the register holding the cell, and the mask
	[_] algorithms

[X] dev on the pi
	[X] access
	; $ ssh pi@raspberrypi.local
	[X] tools
		[X] `as` - comes with!

[X] emulataor
	[X] via qemu userland emulation
	: $ arm-none-eabi-as foo.s -g -o foo.o
	: $ arm-none-eabi-ld foo.o -o foo
	: $ qemu-arm -singlestep -g <port> foo
	: $ gdb-multiarch foo
	: (gdb) target remote localhost:<port>
	: (gdb) layout regs
	: (gdb) list
	: (gdb) p/t $cpsr
		[X] install qemu-arm for userland execution of single programs
		[X] install arm-none-eabi-as, arm-non-eabi-ld
		[X] install gdb-multiarch
	[/] via qemu image
	: https://wiki.debian.org/Arm64Qemu
	: gave up on this approach for now
	[/] add ssh key
	; sudo modprobe nbd
	; sudo qemu-nbd -c /dev/nbd0 debian-9.9.0-openstack-arm64.qcow2
	; sudo mount /dev/nbd0p2 /mnt
	; ssh-add -L > /mnt/home/debian/.ssh/authorized_keys
	; sudo umount /mnt
	; sudo qemu-nbd -d /dev/nbd0
	: temporarily abandoned, as the image has no user defined
	: probably need to run the installer on the image

[X] dedicated learning emulator
	: works, but not ideal
	: https://salmanarif.bitbucket.io/visual/downloads.html
	; $ /usr/local/bin/visual/VisUAL.sh
	: pdf guide, based on the above tool
	: https://web.sonoma.edu/users/f/farahman/sonoma/courses/es310/310_arm/lectures/Chapter_3_Instructions_ARM.pdf
	: doesn't use the same pseudo-instructions as gnu as :/

[_] concepts
: https://azeria-labs.com/arm-data-types-and-registers-part-2/
	[_] data types
		* byte - bits 7,0
		* half word - bits 16,0
		* word bits 31,0
		: MSB first default
		: endianness is configurable though
	[_] op examples
		* ldr   - load word
		* ldrh  - load unsigned half word
		* ldrsh - load signed half word
		* ldrb  - load unsigned byte
		* ldrsb * load signed bytes
		*
		* str    - store word
		* strh   - store unsigned half word
		* strsh  - store signed half word
		* strb   - store unsigned byte
		* strsb  - store signed byte
	[_] registers
		[_] general purpose
		: store locals
			* R0
			: first arg to a function (by convention)
			* R1
			: second arg to a function (by convention)
			* R2
			: third arg to a function (by convention)
			* R3
			: fourth arg to a function (by convention)
			* R4
			* R5
			* R6
			* R7
			: stores syscall number
			* R8
			* R9
			* R10
		[_] special or general purpose
		: store locals OR program execution state
			* R11 / FP - the frame pointer
			: helps track boundaries on the stack
			* R12 / IP - intra procedural call
		[_] special
		: only for program execution
			* R13 / SP - stack pointer
			: top of the stack, marks place of stack locals
			: subtract N bytes from it in order to allocate from the stack
			* R14 / LR - link register
			: the place a function call returns to
			* R15 / PC - program counter
			: automatically incremented based on the size of the instructon
			: that has been executed
			: current instruction + 8 in arm state
			: current instruction + 4 in thumb state
			* CPSR     - current program status register

[_] hello world!
: useful guide https://peterdn.com/post/2012/01/14/hello-world-in-arm-assembly/
	[X] simple demo
	; pi@raspberrypi:~/assembly $ cat 0-pc-demo.s
	; .section .text
	; .global _start

	; _start:
	;   mov r0, pc
	;   mov r1, #2
	;   add r2, r1, r1
	;   bkpt
	; pi@raspberrypi:~/assembly $ as 0-pc-demo.s
	; pi@raspberrypi:~/assembly $ ld -o pc-demo a.out
	; pi@raspberrypi:~/assembly $ ./pc-demo
	; Trace/breakpoint trap
	[X] using gdb
	; gdb pc-demo
	; break _start
	; info registers
	; info all-registers
	: install cgdb
	[X] using VisUAL
	: memory map https://salmanarif.bitbucket.io/visual/memory_map.html
	: instructions https://salmanarif.bitbucket.io/visual/memory_map.html
	[X] storing and loading memory
	; mov		r1, #0x00000290
	; since 666 won't fit in a single numeric literal
	; add		r1, r1, #0x0000000a
	; ;		store 666 into random memory location
	; mov		r2, #0x00011000
	; str		r1, [r2]
	; ;		load 666 from that same location
	; ldr		r0, [r2]
*  interesting:
	: mpidr tells you the cpu number
	: https://developer.arm.com/documentation/ddi0500/e/system-control/aarch32-register-descriptions/multiprocessor-affinity-register
